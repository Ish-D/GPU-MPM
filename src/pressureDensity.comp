#version 430 core

layout(local_size_x = GROUP_SIZE) in;

layout(std140, binding = 0) uniform ComputeParameters {
    uint size;
    float ifps;
    float radius;
    uint grid_size;
    float grid_scale;
    uint ranges_offset;
};

layout(std430, binding = 1) buffer GridBuffer { uint grid_buffer[]; };
layout(std430, binding = 5) readonly buffer SrcPositionBuffer { vec4 src_position_buffer[]; };
layout(std430, binding = 6) readonly buffer SrcVelocityBuffer { vec4 src_velocity_buffer[]; };
layout(std430, binding = 8) readonly buffer massBuffer {float mass_buffer[];};
/*
 */
uvec3 get_index(vec3 position, float grid_scale, float offset) {
    return uvec3(floor(position * grid_scale + 1024.0f + offset));
}

uint get_hash(uvec3 index, uint grid_size) {
    return grid_size * (grid_size * index.z + index.y) + index.x;
}

// Kernel function for density calculation (Poly6)
float poly6Kernel(float r, float h) {
    if (r > h) return 0.0;
    float h2 = h * h;
    float r2 = r * r;
    float factor = (h2 - r2) * (h2 - r2) * (h2 - r2);
    return (315.0 / (64.0 * 3.141592 * pow(h, 9))) * factor;
}

// Gradient of the kernel function for pressure calculation (Spiky)
vec3 gradSpikyKernel(vec3 r, float h) {
    float rLength = length(r);
    if (rLength > h || rLength == 0.0) return vec3(0.0);
    float factor = pow(h - rLength, 2.0);
    return (-45.0 / (3.141592 * pow(h, 6))) * factor * (r / rLength);
}

const float SMOOTHING_LEN = 0.1f;
const float VISCOSITY = 1.0f;
const float STIFFNESS = 2000.0f;

void main() {
    uint global_id = gl_GlobalInvocationID.x;
    if(global_id >= size) return;

    vec3 position = src_position_buffer[global_id].xyz;
    vec3 velocity = src_velocity_buffer[global_id].xyz;
    vec3 acceleration = vec3(0.0f);

    uvec3 index = get_index(position, grid_scale, 0.0f);
    for(uint z = 0u; z < 2u; z++) {
        uint Z = (index.z + z) & (grid_size - 1u);
        for(uint y = 0u; y < 2u; y++) {
            uint Y = (index.y + y) & (grid_size - 1u);
            for(uint x = 0u; x < 2u; x++) {
                uint X = (index.x + x) & (grid_size - 1u);
                uint range_index = ranges_offset + get_hash(uvec3(X, Y, Z), grid_size) * 2u;
                uint range_begin = grid_buffer[range_index + 0u];
                uint range_end = grid_buffer[range_index + 1u];
                for(uint i = range_begin; i < range_end; i++) {
                    uint index = grid_buffer[i];
                    if(global_id != index) {
                            // calculate density and pressure
                        }
                    }
            }
        }
    }
}
