#version 430 core

layout(local_size_x = GROUP_SIZE) in;

layout(std140, binding = 0) uniform ComputeParameters {
	uint size;
	float ifps;
	float radius;
	uint grid_size;
	float grid_scale;
	uint ranges_offset;
};

layout(std430, binding = 1) buffer GridBuffer { uint grid_buffer[]; };

layout(std430, binding = 2) writeonly buffer DestPositionBuffer { vec4 dest_position_buffer[]; };
layout(std430, binding = 3) writeonly buffer DestVelocityBuffer { vec4 dest_velocity_buffer[]; };

layout(std430, binding = 4) readonly buffer SrcPositionBuffer { vec4 src_position_buffer[]; };
layout(std430, binding = 5) readonly buffer SrcVelocityBuffer { vec4 src_velocity_buffer[]; };

layout(std430, binding = 6) buffer pressureBuffer { vec4 pressure_buffer[]; };
layout(std430, binding = 7) buffer densityBuffer { vec4 density_buffer[]; };

layout(std430, binding = 8) readonly buffer massBuffer {float mass_buffer[];};
layout(std430, binding = 9) readonly buffer interactionBuffer {vec4 interaction_buffer[];};

/*
 */
uvec3 get_index(vec3 position, float grid_scale, float offset) {
	return uvec3(floor(position * grid_scale + 1024.0f + offset));
}

uint get_hash(uvec3 index, uint grid_size) {
	return grid_size * (grid_size * index.z + index.y) + index.x;
}

vec3 plane_collision(vec4 plane, vec3 position, vec3 velocity, float radius) {
	float depth = dot(plane, vec4(position, 1.0f)) - radius;
	if(depth < -1e-4f) {
		vec3 normal = -plane.xyz;
		vec3 relative_velocity = -velocity;
		vec3 tangent_velocity = relative_velocity - normal * dot(relative_velocity, normal);
		return normal * (depth * 2.0f) + relative_velocity * 0.08f + tangent_velocity * 0.06f;
	}
	return vec3(0.0f);
}

vec3 sphere_collision(vec3 position_0, vec3 velocity_0, vec3 position_1, vec3 velocity_1, float radius) {
	vec3 direction = position_1 - position_0;
	float distance = length(direction);
	float depth = distance - radius - radius;
	if(depth < -1e-4f && distance > 1e-4f) {
		vec3 normal = direction / distance;
		vec3 relative_velocity = velocity_1 - velocity_0;
		vec3 tangent_velocity = relative_velocity - normal * dot(relative_velocity, normal);
		return normal * (depth * 1.0f) + (relative_velocity * 0.04f + tangent_velocity * 0.03f) * clamp(1.0f + depth * 2.0f / radius, 0.0f, 1.0f);
	}
	return vec3(0.0f);
}

// Kernel function for density calculation (Poly6)
float poly6Kernel(float r, float h) {
	if (r > h) return 0.0;
	float h2 = h * h;
	float r2 = r * r;
	float factor = (h2 - r2) * (h2 - r2) * (h2 - r2);
	return (315.0 / (64.0 * 3.141592 * pow(h, 9))) * factor;
}

// Gradient of the kernel function for pressure calculation (Spiky)
vec3 gradSpikyKernel(vec3 r, float h) {
	float rLength = length(r);
	if (rLength > h || rLength == 0.0) return vec3(0.0);
	float factor = pow(h - rLength, 2.0);
	return (-45.0 / (3.141592 * pow(h, 6))) * factor * (r / rLength);
}

const float SMOOTHING_LEN = 0.1f;
const float VISCOSITY = 1.0f;
const float STIFFNESS = 2000.0f;

void main() {
	uint global_id = gl_GlobalInvocationID.x;
	if(global_id >= size) return;

	vec3 position = src_position_buffer[global_id].xyz;
	vec3 velocity = src_velocity_buffer[global_id].xyz;
	vec3 acceleration = vec3(0.0f);

	vec3 totalForce = vec3(0.0f);
	vec3 impulse = plane_collision(vec4(0.0f, 0.0f, 1.0f, 0.0f), position, velocity, radius);
	vec3 pressureForce = vec3(0.0);
	vec3 viscosityForce = vec3(0.0);
	float density = 0.0f;

	[[branch]] if (interaction_buffer[0].w == 1.0f) {
		impulse += sphere_collision(position, velocity, interaction_buffer[0].xyz, vec3(0,0,0), 0.6f);
	}

	uvec3 index = get_index(position, grid_scale, 0.0f);
	for(uint z = 0u; z < 2u; z++) {
		uint Z = (index.z + z) & (grid_size - 1u);
		for(uint y = 0u; y < 2u; y++) {
			uint Y = (index.y + y) & (grid_size - 1u);
			for(uint x = 0u; x < 2u; x++) {
				uint X = (index.x + x) & (grid_size - 1u);
				uint range_index = ranges_offset + get_hash(uvec3(X, Y, Z), grid_size) * 2u;
				uint range_begin = grid_buffer[range_index + 0u];
				uint range_end = grid_buffer[range_index + 1u];
				for(uint i = range_begin; i < range_end; i++) {
					uint index = grid_buffer[i];
					if(global_id != index) {
						// Calculate impulse
						vec3 position_1 = src_position_buffer[index].xyz;
						vec3 velocity_1 = src_velocity_buffer[index].xyz;
						impulse += sphere_collision(position, velocity, position_1, velocity_1, radius);

						// Calculate pressure
						vec3 delta = position - position_1;
						float r = length(delta);
						// Calculating local density approximation
						density += poly6Kernel(r, radius) * mass_buffer[index];

						float pressure = density - 1000.0f;
						// Applying pressure force calculation using Spiky kernel gradient
						pressureForce -= gradSpikyKernel(delta, radius) * pressure;

						// calculate viscosity
						[[branch]] if (r < SMOOTHING_LEN) {
							float weight = (radius - r) / radius;
							viscosityForce =  weight * (velocity_1 - velocity);
						}
					}
				}
			}
		}
	}

//	impulse = pressureForce;
	float len = length(impulse);
	if(len > 32.0f) impulse *= 32.0f / len;

	viscosityForce *= VISCOSITY;
	totalForce = (vec3(0.0f, 0.0f, -9.81f) * density);

	len = length(totalForce);
	if(len > 32.0f) totalForce *= 32.0f / len;

	// Integrate
	// Limit position/velocity to a cube
	[[branch]] if (position.x > 5.0f) {
		position.x = 5.0f;
		velocity.x = -0.01f;
	}
	[[branch]] if (position.x < -5.0f) {
		position.x = -5.0f;
		velocity.x = 0.01f;
	}

	[[branch]] if (position.y > 5.0f) {
		position.y = 5.0f;
		velocity.y = -0.01f;
	}
	[[branch]] if (position.y < -5.0f) {
		position.y = -5.0f;
		velocity.y = 0.01f;
	} 	[[branch]] if (position.z < 0.0f) {
		position.z = 0.0f;
		velocity.z = 0.1f;
	}

	// new Calculations
//	acceleration = totalForce/density;
//	velocity += ifps * acceleration;
//	position += ifps * velocity;

	// old calculations
	position += velocity * ifps;
	velocity.z -= 2.0f * ifps * mass_buffer[global_id];
	velocity += impulse;

	dest_position_buffer[global_id] = vec4(position, 0.0f);
	dest_velocity_buffer[global_id] = vec4(velocity, 0.0f);

	index = get_index(position, grid_scale, 0.5f) & (grid_size - 1u);
	grid_buffer[global_id] = get_hash(index, grid_size);
}
