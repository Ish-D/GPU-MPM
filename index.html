<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <style>
        body {
            background-color: #f5f5f5;
            padding: 50px;
            width: 80%;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Roboto', sans-serif;
            color: #333;
        }

        h1, h2, h3, h4 {
            font-family: 'Roboto Slab', serif;
            color: #2c3e50;
        }

        kbd {
            color: #333;
        }

        blockquote {
            color: #555;
            border-left: 5px solid #8e44ad;
            padding: 10px;
            background-color: #eee;
        }

        table.custom-tbl {
            border-collapse: collapse;
            width: 100%;
        }

            table.custom-tbl th, table.custom-tbl td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }

            table.custom-tbl th {
                background-color: #3498db;
                color: white;
            }

            table.custom-tbl td {
                background-color: #ecf0f1;
            }

        ul {
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }
    </style>

    <title>CS 184 GPU-MPM</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto+Slab|Roboto:300,400,500,700" rel="stylesheet" />

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async=async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>

    <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
    <h1 align="middle">Final Project: Real-Time GPU Smoothed-Particle Hydrodynamics 3D Fluid Simulation</h1>
    <h2 align="middle">Team 62: Ishan Darji, Dylan Rosario, Harkeerat Singh, Zachary Yan</h2>

    <br /><br />


    <div>
        <h2 align="middle">Abstract</h2>
        <p>
            For this project, we aimed to create a real-time Smoothed-Particle Hydrodynamics (SPH) program to accurately model a 3D fluid. With this simulation, we can render images depicting an originally solid object in freefall that immediately acts as a fluid. In addition, a key core software development kit (SDK) assists with generating the environment for the simulation. All of these tools facilitate the implementation of our SPH to successfully simulate the behavior of the fluid under interactive input from a user.
        </p>

    </div>

    <div>
        <h2 align="middle">Technical Approach</h2>
        <p>
            From a technical perspective, our implementation was based upon a similar SPH example [1] to provide a base framework of how to most effectively model fluid flow with particles. The bulk of the techniques used in this project center around calculating the position, velocity, and acceleration for any given particle at each time step. From previous assignments, we know that force is equal to mass multiplied by acceleration. Our main goal is to sum all of the forces that act upon every particle and form kinematics equations. With these equations, we can compute the new positions and velocities for each particle in the simulation. This involves integrating the interactions such as pressure and viscosity forces between particles, as well as handling collisions and boundary constraints effectively. By leveraging the compute capabilities of modern GPUs, we were able to perform these calculations in parallel, significantly speeding up the simulation while maintaining high fidelity in the fluid's dynamic behavior.
        </p>
        <p>
            Our GPU from Telluism [2] is essential for rendering the scene. This lays out a structure for defining everything needed to render the interactive scene including initialization of vectors to store the position, velocity, and acceleration of each particle. Easy accessibility and efficient storage of this data is key for speeding up run time and ultimately forming an approachable program. Also, it
            facilitates real-time updates and interactions, allowing users to dynamically alter parameters and immediately see the effects on the fluid simulation. The use of this advanced hardware and optimized data structures ensures that our application can handle thousands of particles simultaneously with minimal latency, providing a seamless and engaging experience for users interested in exploring fluid dynamics visually.
        </p>
        <p>
            A major component of our project includes the ability to control the motion of the fluid as the user, specifically mouse movements detected on the fluid will introduce new forces into the scene. These extra forces are given a magnitude we deemed representative of the motion and can then simply be added to the existing force vectors we created. This will cause real-time movement of the fluid since new external forces are being added.
        </p>

        <p>
            To further vary our approach from previous references, we imported a unique object in an effort to simulate an interesting flow of particles that differs from a waterfall for example. This object begins as a 3D mesh which proved to cause problems when trying to import into our program, since there are no easily defined coordinates of particles. Our solution included converting this to a point cloud so that the Telluism core SDK can process the desired object and perform the SPH simulation. With the help of an open source project [3], we are able to convert an object to a list of positions defining each particle of the object. From this, we can now parse through these positions and perform the necessary calculations.


        </p>

        <p>
            Throughout the implementation process, we encountered a number of challenges, some of which including data synchronization and performance optimization. GPU programming by nature requires managing data across multiple threads to ensure memory visibility is maintained. We used Vulkan synchronization primitives to control data flow between different stages of the computation.

        </p>

        <p>
            Another obstacle occurred when implementing the interactive abilities of the program. From the user perspective, we wanted to provide as much interactivity as possible by allowing the viewing perspective of the object to change in real-time. Intuitively, the most natural way to do this would be for dragging the mouse to cause rotation and translation around the scene. Ultimately, we settled upon a system of keybinds to control rotation across each of the 3 axes of rotation: x, y, and z. With this in place, the program user can explore the scene and investigate how each individual particle moves.
        </p>

        After completing this project, a great multitude of lessons have been learned. First off, we became aware of how time consuming and complex some other similar methods are. We initially attempted to create a real-time material point method to generate a similar movement. While we gained experience throughout this course by working with similar projects like Cloth Sim, there are a number of methods specifically with grid operations that require too great of an amount of debugging. Ultimately, this taught us how to pivot and choose a different direction for our project. We were still able to use the same GPU base, but instead we went the route with SPH. This process brought us a greater understanding of how to utilize powerful SDKs to accomplish our desired goal.

        </p>
    </div>

    <h2 align="middle">Results</h2>
    </a>

    <div align="middle">
        <img src="img/initial.png" align="middle" width="500vw" />
        <figcaption>Particles in Initial State</figcaption>

        <img src="img/in-air.png" align="middle" width="500vw" />
        <figcaption>Particles Mid-Air</figcaption>

        <img src="img/on-ground.png" align="middle" width="500vw" />
        <figcaption>Particles Settled on Ground</figcaption>

    </div>

    <h2 align="middle">References</h2>
    <ul>
        <li>[1] <a href="https://doc.magnum.graphics/magnum/fluidsimulation3d_2SPH_2SPHSolver_8cpp-example.html">Magnum: 3D Fluid Simulation</a></li>
        <li>[2] <a href="https://tellusim.com/evaluation/">Tellusim Evaluation</a></li>
        <li>[3] <a href="https://www.danielgm.net/cc/">CloudCompare</a></li>
    </ul>

    <h2 align="middle">Team Contributions</h2>
    <ul>
        <li>
            <strong>Dylan Rosario</strong>
            <ul>
                <li>Helped write parts of the report including the abstract, technical approach, and results.</li>
                <li>Created final project showcase video.</li>
                <li>Implemented interactive elements of the program.</li>
                <li>General debugging of the code and general editing of the report.</li>
            </ul>
        </li>
        <li><strong>Ishan Darji</strong></li>
        <ul>
            <li>
                Integrated SPH methods for realistic fluid behavior.
            </li>
            <li>
                Optimized fluid dynamics algorithms for improved stability and performance.
            </li>
        </ul>
        <li>
            <strong>Zachary Yan</strong>
            <ul>
                <li>
                    Implemented the input parsing, sampling the original model for a point cloud to particles for simulation.
                </li>
            </ul>
        </li>
        <li>
            <strong>Harkeerat Singh</strong>
            <ul>
                <li> Developed the GPU compute shader for fluid simulation, focusing on kernel functions, pressure, and viscosity calculations.</li>
                <li>
                    Contributed to the technical section of the report on computational methods and shader operations.
                </li>
            </ul>
        </li>
    </ul>


</body>
</html>
