<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <style>
        body {
            background-color: #f5f5f5;
            padding: 50px;
            width: 80%;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Roboto', sans-serif;
            color: #333;
        }

        h1, h2, h3, h4 {
            font-family: 'Roboto Slab', serif;
            color: #2c3e50;
        }

        kbd {
            color: #333;
        }

        blockquote {
            color: #555;
            border-left: 5px solid #8e44ad;
            padding: 10px;
            background-color: #eee;
        }

        table.custom-tbl {
            border-collapse: collapse;
            width: 100%;
        }

            table.custom-tbl th, table.custom-tbl td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }

            table.custom-tbl th {
                background-color: #3498db;
                color: white;
            }

            table.custom-tbl td {
                background-color: #ecf0f1;
            }

        ul {
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }
    </style>

    <title>CS 184 GPU-MPM</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto+Slab|Roboto:300,400,500,700" rel="stylesheet" />

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async=async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>

    <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
    <h1 align="middle">Final Project: GPU MPM</h1>
    <h2 align="middle">Team 62: Ishan Darji, Dylan Rosario, Harkeerat Singh, Zachary Yan</h2>

    <br /><br />


    <div>
        <h2 align="middle">Abstract</h2>
        <p> For this project, we aimed to create a GPU material point method simulation. With this simulation, we can render images depicting a falling solid object that acts as a fluid upon impact with the ground. MPM utilizes a combination of Lagrangian and Eulerian methods to calculate and simulate the motion of the individual particles of a complex object. With the help of a core SDK that assists with generating an environment for the simulation, we were able to implement an MPM to create our scene that the user can interact with in real-time.</p>

    </div>

    <div>
        <h2 align="middle">Technical Approach</h2>
        <p>
            From a technical perspective, our implementation was based on the foundational principles of MPM as described by Jiang et al. (2016) and extended by other research in the field. As a hybrid Eulerian-Lagrangian method, MPM involves tracking masses of particles through a background grid where we calculate the update in velocity, position, and force accumulation. The nature of MPM allows for it to handle deformations and topological changes in material, making it suitable for simulating phenomena like a solid object acting fluid upon impact. The compute shader was the main platform for which we implemented an array of parallel computations. By design, there were several key shaders critical for a functional MPM:

        </p>

        <p>
            <b>Particle-to-Grid (P2G) Transfer:</b> Here, we implemented the transfer of mass and momentum from particles to the grid in order to translate particle properties for solving dynamics in a grid-based framework. The influence on the grid nodes was computed via a weight function to determine the impact on a given particle on its surrounding nodes. The operations were further optimized to minimize the computational overhead and used atomic operations so as to ensure that updates to the grid properties from multiple particles were correctly synchronized without conflicts. Attention was also given towards the layout and access patterns of the GPU buffers to enhance memory throughput and reduce latency.

        </p>

        <p>
            <b>Grid Operations:</b>  Following the P2G transfer, the grid operations involved updating the velocities and forces at each grid node based on the aggregated mass and momentum from the particles. We additionally employed barrier synchronization to ensure all updates to the grid were completed before any data was read or written, allowing us to guarantee consistency across all threats and prevent parallel data processing pitfalls such as race conditions and partial updates.


        </p>

        <p>
            <b>Grid-to-Particle (G2P) Transfer:</b> In this phase, the new velocities and positions are calculated for each particle based on the grid nodes’ updated states. This process involves interpolating the grid velocities to particle positions so that they receive momentum and movement reflective of the interaction with the grid and other particles. We also close the loop of the MPM cycle to allow the simulation to progress dynamically over time.

        </p>

        <p>
            <b>Boundary Conditions and Collision Handling:</b> We integrated collision detection and response directly into the computer shaders so as to leverage the execution capabilities of the GPU. Each particle position was checked against predefined boundaries of the simulation domain, in which case if a collision occurred, the position and velocity were adjusted accordingly per physically based reflection and damping models. This process prevents particles from escaping the simulation domain or behaving unrealistically upon interaction with the boundaries

        </p>

        <p>
            Throughout the implementation process, we encountered a number of challenges, some of which including data synchronization and performance optimization. GPU programming by nature requires managing data across multiple threads to ensure memory visibility is maintained. We used Vulkan’s synchronization primitives to control data flow between different stages of the computation.
            Additional problems we encountered  include the process of converting a 3D mesh to a point cloud so that the Telluism core SDK can process the desired object and perform the MPM simulation. With the help of an open source project [3], we are able to convert an object to a list of positions defining each particle of the object. From this, we can now parse through these positions within our MPM.
            Another obstacle occurred when implementing the interactive abilities of the program. From the user perspective, we wanted to provide as much interactivity as possible by allowing the viewing perspective of the object to change in real-time. Intuitively, the most natural way to do this would be for dragging the mouse to cause rotation and translation around the scene. Ultimately, we settled upon a system of keybinds to control rotation across each of the 3 axes of rotation: x, y, and z. With this in place, the program user can explore the scene much easier and investigate how each individual particle moves.

        </p>

        <p>
            After completing this project, a great multitude of lessons have been learned. First, we simply learned how time consuming it is to fully integrate an MPM. While we gained experience throughout this course by working with similar projects like Cloth Sim, there are many methods specifically with grid operations that required a great amount of debugging. Also, we gained a greater understanding of how to harness a powerful core SDK to facilitate our project’s end goal. The direction we chose to go is just one of many we could have chosen with this base, and now with our new knowledge we are better equipped to form new projects from this same setup.
        </p>
    </div>

    <h2 align="middle">Results</h2>
    </a>

    <div align="middle">
        <img src="img/initial.png" align="middle" width="500vw" />
        <figcaption>Particles in Initial State</figcaption>

        <img src="img/in-air.png" align="middle" width="500vw" />
        <figcaption>Particles Mid-Air</figcaption>

        <img src="img/on-ground.png" align="middle" width="500vw" />
        <figcaption>Particles Settled on Ground</figcaption>

    </div>

    <h2>Team Contributions:</h2>
    <ul>
        <li>
            <strong>Dylan Rosario</strong>
            <ul>
                <li>Helped write parts of the report including the abstract, technical approach, and results.</li>
                <li>Created final project showcase video.</li>
                <li>Implemented interactive elements of the program.</li>
                <li>General debugging of the code and general editing of the report.</li>
            </ul>
        </li>
        <li><strong>Ishan Darji</strong></li>
        <li><strong>Zachary Yan</strong></li>
        <li>
            <strong>Harkeerat Singh</strong>
            <ul>
                <li>Developed the compute shader for GPU-MPM, focusing on P2G, G2P, grid operations, and collision detection.</li>
                <li>
                    Assisted in the write up of the technical section for the report.
                </li>
            </ul>
        </li>
    </ul>


</body>
</html>
